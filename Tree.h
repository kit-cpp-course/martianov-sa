/***************************************************************************************

	Вся реализация класса в одном файле, так как при использовании шаблонов недоступна
	раздельная компиляция.

	Комментарии перед описанием методов продублированы, чтобы в других файлах, где
	подключен этот заголовок, они были доступны.
	
	Для класса дерева реализовано "правило трех", но это сделано исключительно в целях
	предотвращения утечки памяти. Удобнее работать с деревьями, храня их в динамической
	памяти.

	ВАЖНО: не смотря на реализацию "правила трех", утечка памяти может возникнуть, если
	у пользовательского типа, передаваемого в шаблон, не было реализовано это правило.

	Очевидно, если этот класс будет наследоваться, нет необходимости реализовывать "правило
	трех" в его потомках - оно унаследуется.

***************************************************************************************/

#pragma once

/**
  Класс дерева.

  Дерево представляет собой узел, в котором хранится значение произвольного типа
  (поэтому используется шаблон), а так же указатели на его левую и правую ветки,
  которые тоже являются деревьями.
*/
template <typename T>
class Tree
{
protected:
	// Создает копию дерева.
	Tree * copy(Tree * source);

public:
	// Значение узла
	T value;

	// Левый узел
	Tree * left;

	// Правый узел
	Tree * right;

	/**
	  Основной конструктор.

	  Принимает значение, которое хранит данный узел и указатели на левый и правый узлы.
	  Именно эти узлы и будут привязаны, а не их копии. По умолчанию создает дерево без
	  левой и правой веток.
	*/
	Tree(T value, Tree * left = 0, Tree * right = 0);

	// Оператор присваивания.
	~Tree();

	// Конструктор копирования.
	Tree(const Tree & source);

	// Оператор присваивания.
	Tree & operator=(const Tree & source);
};

/**
  Основной конструктор.

  Принимает значение, которое хранит данный узел и указатели на левый и правый узлы.
  Именно эти узлы и будут привязаны, а не их копии. По умолчанию создает дерево без
  левой и правой веток.
*/
template<typename T>
Tree<T>::Tree(T value, Tree * left, Tree * right) :
	value(value), left(left), right(right)
{}

// Основной деструктор.
template<typename T>
Tree<T>::~Tree()
{
	if (left) delete left;
	if (right) delete right;
}

// Конструктор копирования.
template<typename T>
Tree<T>::Tree(const Tree & source) :
	value(source.value), left(copy(source.left)), right(copy(source.right))
{}

// Оператор присваивания.
template<typename T>
Tree<T> & Tree<T>::operator=(const Tree & source)
{
	if (left) delete left;
	if (right) delete right;
	value = source.value;
	left = copy(source.left);
	right = copy(source.right);
	return *this;
}

template<typename T>
Tree<T> * Tree<T>::copy(Tree * source)
{
	Tree * result = 0;
	if (source)
	{
		result = new Tree(source->value);
		result->left = (source->left) ? copy(source->left) : 0;
		result->right = (source->right) ? copy(source->right) : 0;
	}
	return result;
}