#pragma once
#include "Tree.h"
#include "HuffDict.h"

/**
 * Класс дерева Хаффмана.
 *
 * Потомок более общего класса - дерева. Значение его узлов - "лексемы Хаффмана".
 * При создании дерева также заполняются коды Хаффмана в лексемах в переданном словаре.
 */
class HuffTree : public Tree<HuffToken *>
{
	/**
	 * Конструктор, формирующий дерево Хаффмана состоящее из одного узла.
	 *
	 * Принимает "лексему Хаффмана", которое хранит данный узел и указатели на левый и
	 * правый узлы. Именно эти узлы и будут привязаны, а не их копии. По умолчанию создает
	 * дерево без левой и правой веток. Используется только внутри класса.
	 */
	HuffTree(HuffToken * value = new HuffToken(), HuffTree * left = 0, HuffTree * right = 0);

	/**
	 * Объединение последних двух узлов отсортированного по частотам массива узлов.
	 *
	 * Создает новый узел. Два последних узла исходного массива привязываются к новому, как его
	 * левый и правый узлы, и убираются из массива. Новый узел помещается в конец массива. Лексема,
	 * помещаемая в узел имеет символ '0' (выбрано для удобства, в любом случае, какой-то символ
	 * там должен быть, на работоспособность алгоритма это никак не влияет), частоту символа, равную
	 * сумме частот символов лексем двух исходных узлов, и пустой код.
	 */
	void combineLastNodes(HuffTree ** nodes, size_t lastNodeNum);
	
	/**
	 * Уменьшение размера массива узлов.
	 *
	 * Создает новый узел. Два последних узла исходного массива привязываются к новому, как его
	 * левый и правый узлы, и убираются из массива. Новый узел помещается в такое место массива,
	 * чтобы сохранялась сортировка по частотам.
	 */
	void reduceNodes(HuffTree ** nodes, size_t lastNodeNum);
	
	/**
	 * Изменение кодов "лексем Хаффмана" в узлах.
	 *
	 * Если узел привязывается слева к другому узлу, то для лексемы в этом узле и всех узлах ниже
	 * него к началу кода добавляется 0, если привязывание справа, то добавляется 1.
	 */
	void modifyCode(HuffTree * node, char prefix);
	
	/**
	 * Функция, меняющая два узла местами.
	 */
	void swapNodes(HuffTree * a, HuffTree * b);

public:
	/**
	 * Основной конструктор.
	 *
	 * "Обертывает" каждую лексему в узел, и помещает все узлы в массив (так как лексемы
	 * отсортированы по частотам, массив узлов, соответственно, тоже). Создаются новые узлы и
	 * к каждому из них слева и справа "привязываются" два исходных, и один новый узел заменяет
	 * два исходных в массиве. Это происходит до тех пор, пока в массиве не останется один узел,
	 * к которому привязаны все исходные, он и становится вершиной дерева Хаффмана.
	 */
	HuffTree(HuffDict & huffTokens);
};
