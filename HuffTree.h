#pragma once
#include "Tree.h"
#include "HuffDict.h"

/**
  Класс дерева Хаффмана.

  Потомок более общего класса - дерева. Значение его узлов - "лексемы Хаффмана".
  При создании дерева также заполняются коды Хаффмана в лексемах в переданном словаре.
*/
class HuffTree : public Tree<HuffToken>
{
	/**
	  Конструктор, формирующий дерево Хаффмана состоящее из одного узла.

	  Принимает "лексему Хаффмана", которое хранит данный узел и указатели на левый и
	  правый узлы. Именно эти узлы и будут привязаны, а не их копии. По умолчанию создает
	  дерево без левой и правой веток. Используется только внутри класса.
	*/
	HuffTree(HuffToken value = HuffToken(), HuffTree * left = 0, HuffTree * right = 0);

	/**
	  Создание массива узлов.

	  Создает в динамической памяти массив узлов будущего дерева.
	*/
	HuffTree * createNodes(HuffDict & huffTokens);

	/**
	  Уменьшение размера массива узлов.

	  Создает новый узел. Два последних узла исходного массива привязываются к новому, как его
	  левый и правый узлы, и убираются из массива. Новый узел помещается в такое место массива,
	  чтобы сохранялась сортировка по частотам.
	*/
	void reduceNodes(HuffTree * nodes, size_t lastNodeNum, HuffDict & huffTokens);

	/**
	  Объединение последних двух узлов отсортированного по частотам массива узлов.

	  Создает новый узел. Два последних узла исходного массива привязываются к новому, как его
	  левый и правый узлы, и убираются из массива. Новый узел помещается в конец массива. Лексема,
	  помещаемая в узел имеет символ '0' (выбрано для удобства, в любом случае, какой-то символ
	  там должен быть, на работоспособность алгоритма это никак не влияет), частоту символа, равную
	  сумме частот символов лексем двух исходных узлов, и пустой код.
	*/
	void combineLastNodes(HuffTree * nodes, size_t lastNodeNum, HuffDict & huffTokens);
	
	/**
	  Изменение кодов "лексем Хаффмана" в узлах.

	  Если узел привязывается слева к другому узлу, то для лексемы в этом узле и всех узлах ниже
	  него к началу кода добавляется 0, если привязывание справа, то добавляется 1.
	*/
	void modifyCode(HuffTree * node, char prefix, HuffDict & huffTokens);
	
	// Функция, меняющая два узла местами.
	void swapNodes(HuffTree & a, HuffTree & b);

public:
	/**
	  Основной конструктор.

	  "Обертывает" каждую лексему в узел, и помещает все узлы в массив (так как лексемы
	  отсортированы по частотам, массив узлов, соответственно, тоже). Создаются новые узлы и
	  к каждому из них слева и справа "привязываются" два исходных, и один новый узел заменяет
	  два исходных в массиве. Это происходит до тех пор, пока в массиве не останется один узел,
	  к которому привязаны все исходные, он и становится вершиной дерева Хаффмана.
	*/
	HuffTree(HuffDict & huffTokens);
};
